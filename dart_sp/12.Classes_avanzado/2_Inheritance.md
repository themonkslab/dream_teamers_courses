# _Inheritance_ o Herencia

Supongamos que queremos representar a distintos tipos de animales. Podemos decir
que todos los animales necesitan dormir, comer y reproducirse pero no todos por
ejemplo, pueden volar.

Vamos a empezar en esta oportunidad escribiendo un test pero para ello tenemos
que crear que crear un paquete. Recuerdan c√≥mo hacerlo? Vamos a crear un paquete
que compartiremos a lo largo de toda esa secci√≥n.

Si creamos un paquete con Dart (pueden hacerlo r√°pidamente con `cmd` + `shift` +
`p` en VSCode, escribiendo Dart y seleccionando 'New Project'), esto es lo que
van a ver:

Una carpeta `example`, que es la que tiene nuestro `main` o punto de ingreso:

```dart
import 'package:classes_advanced/classes_advanced.dart';

void main() {
  var awesome = Awesome();
  print('awesome: ${awesome.isAwesome}');
}
```

Una carpeta `lib/src` que tiene la funcionalidad de nuestro paquete, en la
librer√≠a:

```dart
// TODO: Put public facing types in this file.

/// Checks if you are awesome. Spoiler: you are.
class Awesome {
  bool get isAwesome => true;
}
```

Y la carpeta `test`:

```dart
import 'package:classes_advanced/classes_advanced.dart';
import 'package:test/test.dart';

void main() {
  group('A group of tests', () {
    final awesome = Awesome();

    setUp(() {
      // Additional setup goes here.
    });

    test('First Test', () {
      expect(awesome.isAwesome, isTrue);
    });
  });
}
```

Si nos concentramos en los primeros dos archivos (dentro de las primeras dos
carpetas mencionadas), podemos ver la clase `Awesome`. Ella tiene un _getter_
llamado `isAwesome` ('es incre√≠ble'). En la funci√≥n `main`, instanciamos la
clase y luego imprimimos algo con su _getter_.

Luego, si nos movemos al √∫nico test, van a encontrar un par de cosas nuevas:
`group` y `setUp`. Cada funci√≥n tiene varios par√°metros de configuraci√≥n pero
vamos a ir de a poco.

La funci√≥n `group`, nos permite agrupar nuestros tests. El primer par√°metro
sirve para introducir una `String` a modo de descripci√≥n que va a ser inclu√≠da
en cada descripci√≥n de los tests que lo integren. Observen el siguiente ejemplo:

```dart
group('A group description', () {
    test('...that goes here.', () {
    });
    test('...that goes also here.', () {
    });
    test('...that goes finally here too.', () {
    });
  });
```

Cuando corran esos tests, es esto lo que ver√°n en la consola:

```shell
‚úì A group description ...that goes here.
‚úì A group description ...that goes also here.
‚úì A group description ...that goes finally here too.
Exited
```

Por otro lado, la funci√≥n `setUp` registra un _callback_ que va a ser ejecutado
antes de cada test. Supongan el siguiente ejemplo:

```dart
import 'package:classes_advanced/classes_advanced.dart';
import 'package:test/test.dart';

void main() {
  group('A group of tests', () {
    final awesome = Awesome();

    setUp(() {
      print('üöß setup');
    });

    test('First Test', () {
      expect(awesome.isAwesome, isTrue);
    });

    test('Second Test', () {
      expect(!awesome.isAwesome, isFalse);
    });
  });
}
```

Es esto lo que ver√≠an en su consola:

```shell
üöß setup
‚úì A group of tests First Test
üöß setup
‚úì A group of tests Second Test
Exited
```

Pueden observar que para cada test, se corri√≥ una vez la funci√≥n `setUp`. Qu√©
pueden deducir del siguiente ejemplo? üíÄ T√≥mense un tiempo para pensarlo:

```dart
import 'package:classes_advanced/classes_advanced.dart';
import 'package:test/test.dart';

void main() {
  group('A group of tests', () {
    final awesome = Awesome();

    setUp(() {
      print('üöß setup');
    });

    test('First Test', () {
      expect(awesome.isAwesome, isTrue);
    });

    test('Second Test', () {
      expect(!awesome.isAwesome, isFalse);
    });
  });

  test('A test out of the group', () {
    expect(1, 1);
  });
}
```

Pudieron ver qu√© sucedi√≥? El `group` define un _inner scope_, un √°mbito en el
cual instancia el `Awesome`, registra un `setUp` y dem√°s. Todo lo que suceda
all√≠ es solamente funcional dentro del grupo. Por ello, nuestro test final,
aqu√©l fuera del `group`, no imprime el 'üöß setup':

```shell
üöß setup
‚úì A group of tests First Test
üöß setup
‚úì A group of tests Second Test
‚úì A test out of the group
Exited
```

Dicho todo lo anterior, vamos a borrar todo en el archivo
`classes_advanced_test.dart` salvo el `main`, lo mismo en el
`classes_advanced_example.dart` y todo en el `classes_advanced_base.dart`.

Empecemos a escribir un test que nos permita comprobar la creaci√≥n de una clase
llamada `Animal` que pueda comer, dormir y respirar. üíÄ Intenten hacerlo
ustedes.

Yo lo har√≠a de la siguiente manera:

```dart
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    test('when sleep is called, then should print sleeping', () {});
    test('when eat is called, then should print eating', () {});
    test('when breath is called, then should print breathing', () {});
  });
}
```

Perfecto! Ya lo tenemos. Ahora bien, qu√© es lo primero que deber√≠amos tener para
poder testar un `Animal`? Exacto, la clase `Animal`. Yo podr√≠a entonces escribir
algo as√≠:

```dart
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    test('when sleep is called, then it should print "sleeping"', () {
      // Given
      final animal = Animal();
    });

    test('when eat is called, then it should print "eating"', () {
      // Given
      final animal = Animal();
    });

    test('when breathe is called, then it should print "breathing"', () {
      // Given
      final animal = Animal();
    });
  });
}
```

Esto har√° que antes de cada test, tengamos una instancia de `Animal` para
ejecutar sus m√©todos. üíÄ Ya saben una forma mejor de hacer lo anterior. Van a
probar?

```dart
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    // Given
    Animal animal;
    
    setUp(() {
      animal = Animal();
    });

    test('when sleep is called, then it should print "sleeping"', () {
    });

    test('when eat is called, then it should print "eating"', () {
    });

    test('when breathe is called, then it should print "breathing"', () {
    });
  });
}
```

Podr√≠amos haberlo hecho una sola vez en el `setUp` y eso nos ahora mucho c√≥digo!

F√≠jense ahora c√≥mo nuestro test nos va indicando qu√© necesitamos: ya nos arroja
un error porque dicha clase no existe. La creamos en nuestro
`classes_advanced_base.dart`? Lo haremos simple: `class Animal {}`.

Ya tenemos nuestra clase y nuestros tests dejaron de fallar! Ahora que ya
tenemos nuestro _Given_, vamos a implementar nuestros _When_ dentro de cada
test:

```dart
import 'package:classes_advanced/src/classes_advanced_base.dart';
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    //Given
    late Animal animal;
    setUp(() {
      animal = Animal();
    });
    test('when sleep is called, then it should print "sleeping"', () {
      // When
      animal.sleep();
    });

    test('when eat is called, then it should print "eating"', () {
      // When
      animal.eat();
    });

    test('when breathe is called, then it should print "breathing"', () {
      // When
      animal.breathe();
    });
  });
}
```

Nuevo error ya que esos m√©todos no est√°n implementados! Vamos a hacerlo en la
clase que creamos!

```dart
class Animal {
  void sleep() => print('sleeping');
  void eat() => print('eating');
  void breathe() => print('breathing');
}
```

Ya no tenemos errores! F√≠jense c√≥mo paso a paso nuestros propios tests nos gu√≠an
a la implementaci√≥n.

Ahora podr√≠amos correrlos y no ver√≠amos ning√∫n fallo pero tampoco estar√≠amos
testeando nada en particular. C√≥mo hacemos para testear lo que se imprime en
nuestra consola? üòí Existen maneras de hacerlo pero aun son muy complejas lo que
nos lleva a modificar un poco nuestro c√≥digo original y __ser creativos a la
hora de testear, lo que es fundamental ya que en escenarios complejos no siempre
las formas conocidas les van a permitir obtener los resultados esperados__.

En este caso, una forma podr√≠a ser en lugar de imprimir nuestra funci√≥n,
retornar una `String` que luego imprimiremos. Modifiquemos entonces nuestro test
primero:

```dart
import 'package:classes_advanced/src/classes_advanced_base.dart';
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    //Given
    late Animal animal;
    setUp(() {
      animal = Animal();
    });
    test('when sleep is called, then it should print "sleeping"', () {
      // When
      final result = animal.sleep();
    });

    test('when eat is called, then it should print "eating"', () {
      // When
      final result = animal.eat();
    });

    test('when breathe is called, then it should print "breathing"', () {
      // When
      final result = animal.breathe();
    });
  });
}
```

Listo, no tenemos errores! Pero... ü§® deber√≠amos tener errores! üíÄ Vayan a
elucubrarlo ustedes!

Ya se dieron cuenta qu√© sucedi√≥? Exacto! Estamos escribiendo de forma poco
precisa nuestro c√≥digo porque la variable `result` se adapta al resultado ya que
no le establecimos un tipo. Vamos a ponernos m√°s firmes:

```dart
import 'package:classes_advanced/src/classes_advanced_base.dart';
import 'package:test/test.dart';

void main() {
  group('Given an Animal class,', () {
    //Given
    late Animal animal;
    setUp(() {
      animal = Animal();
    });
    test('when sleep is called, then it should print "sleeping"', () {
      // When
      final String result = animal.sleep();
    });

    test('when eat is called, then it should print "eating"', () {
      // When
      final String result = animal.eat();
    });

    test('when breathe is called, then it should print "breathing"', () {
      // When
      final String result = animal.breathe();
    });
  });
}
```

Ahora s√≠ van a ver que falla ya que cada una de las expresiones retorna `void`
en lugar de la `String` que queremos. Una vez m√°s, esto nos gu√≠a a c√≥mo seguir.
üíÄ Vayan a hacer la tarea! ü§£

Modificaremos entonces nuestros m√©todos para retornar `String`s:

```dart
class Animal {
  String sleep() => 'sleeping';
  String eat() => 'eating';
  String breathe() => 'breathing';
}
```

<!-- TODO -CONT-: escribir el Then -->

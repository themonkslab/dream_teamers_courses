# _Errors, Exceptions and Assertions_

Hasta ahora venimos viéndolos pero nunca hablamos detenidamente de ellos y qué
diferencias podemos encontrar entre un tipo y el otro. Vamos a por ello!

__Los errores o _errors_ son fallos provocados por el desarrollador... cuando
hacemos algo mal!__ 🤣 Por ejemplo, podría ser llamar a una función con argumentos
que no son válidos, buscar un elemento en una lista que no tiene dicho índice o
cosas por el estilo! En estos casos, __nuestro programa debería terminar de forma
inmediata__ ya que no es seguro el continuar una vez que se han producido estos errores.

__Las excepciones o _exceptions_ por el otro lado, muestran que algo inesperado
sucedió, algo fuera de nuestro control__. Sin embargo, pueden ser manejadas:
podríamos mostrarle un mensaje al usuario y luego recuperarnos y continuar con
la ejecución.

Finalmente, ya vimos lo que son __las _assertions_ o afirmaciones que nos permiten
chequear el código cuando estamos en _debug mode_ o tiempo de desarrollo,__ pero
lo hicimos en los comienzos de este curso. Ahora que ya las manejamos, vamos a
relacionarlas con los errores y las excepciones!

Es importante tener en cuenta que las _assertions_ en la lista de inicialización
se ejecutan en tiempo de compilación y se omiten en tiempo de ejecución en modo
release o cuando presentamos la app para el usuario. Por lo tanto, __no deben
utilizarse para validar entradas de usuario o comprobar condiciones que se
espera que se produzcan durante la ejecución normal del programa__. __Las
assertions  se utilizan para detectar errores de programación y asegurarse de
que las suposiciones del programador sobre el estado del programa sean correctas
en tiempo de ejecución.__

## Manejando errores en la _initializer list_

En Flutter, _framework_ que trabaja utilizando Dart como lenguaje, contamos con
una estructura basada en _Widgets_ y se dice cada elemento en Flutter es un _Widget_.
Así por ejemplo, si queremos poner un botón en nuestra aplicación, este botón
será un _Widget_ y lo podríamos representar de forma muy simple con una clase:

```dart
class FlutterButton {
  FlutterButton({required this.text});
  final String text;
}
```

Este botón por el momento no podría hacer nada ya que solo recibe el texto que
va a mostrar. Pero qué impediría que le pasemos cuando lo construyamos a este
botón, un `String` vacía?

```dart
void main() {
  final button = FlutterButton(text: '');
  print(button.text);
}
```

Absolutamente nada! Podríamos crear un test entonces, para cerciorarnos de que
si le pasamos un `String` vacía, nuestro constructor va a lanzar una excepción y
si le pasamos una `String` con caracteres, va a retornar normalmente:

```dart
void main() {
  group('Given a FlutterButton', () {
    test('When created with an empty text, Then should throw AssertionError', () {
      expect(() => FlutterButton(text: ''), throwsA(isA<AssertionError>()));
    });

    test('When created with text not empty, should return normally', () {
      expect(() => FlutterButton(text: 'Hello, world!'), returnsNormally);
    });
  });
}
```

Podemos observar varias cosas en nuestros tests:

### Funciones anónimas o referencias a función

- Utilizamos una función anónima como primer argumento en el `expect`:

Ustedes recuerdan que el método `expect` básicamente compara dos argumentos.
Bien, para poder chequear un error lanzado por una _assertion_,
utilizamos `throwsA` o 'lanzar un' en español. Este método recibe una función
que luego será ejecutada durante nuestro test. En el caso presente, dicha
función es `isA<AssertionError>()` que corrobora el tipo de error que va a estar
siendo lanzado por nuestra _assertion_. De esta forma, `throwsA` encapsula a
`isA<AssertionError>()` para ser ejecutada en el `expect`.

Venimos bien hasta ahí? Perfecto. Seguimos!

En el segundo argumento tenemos esta función que lanzará otra
función. En nuestro primer argumento debiéramos tener algo similar y así poder
compararlo: necesitamos entonces una función que lance otra función.

Tenemos ya una función que es la encargada de construir nuestro `FlutterButton`,
el constructor de dicha clase. Nos faltaría entonces una función que dispare
esta función constructora. Para ello, __utilizamos una función anónima que sirve
para encapsular la creación de la instancia de `FlutterButton`__ y así poder
comparar esta con aquella otra función.

Si se les complicó, vuelvan a leerlo detenidamente porque es medio enrevesado! 🤣

- Utilizamos `returnsNormally`

Parecido al caso anterior, solo que este `returnsNormally` es un `matcher` que
machea una llamada a una función cuando no produce ninguna excepción. Por eso,
el valor del primer argumento tiene nuevamente que ser una función anónima.

En ambos casos, __la función anónima es una referencia a una función ya que se va
a ejecutar luego dentro del `expect` así como lo hará el segundo término del
mismo, pudiendo ambos finalmente compararse.__

Ya que entendimos cómo construimos nuestros tests, cómo lo implementamos? Vamos
a utilizar las _assertions_ dentro del constructor, en la _initializer list_.

En cuanto a la ubicación de las _assertions_ en una inicialización de lista, se
recomienda colocarlas al principio, inmediatamente después de los `:`, antes de
cualquier otra expresión. Esto es porque las _initializer list_ se evalúan de
izquierda a derecha, y si hay una expresión inválida en la lista, la excepción
que se genera puede no estar relacionada con la expresión incorrecta. __Colocar
las _assertions_ al principio de la lista ayuda a identificar rápidamente
cualquier problema en los argumentos de entrada.__

```dart
class FlutterButton {
  FlutterButton({required this.text})
      : assert(text.isNotEmpty, 'Text can\'t be empty');
  final String text;
}
```

Ahora sí, si corremos los tests habiendo implementado la clase de esta manera,
vamos a estar seguros de que nuestro botón se va a construir de forma correcta.

Haciendo lo anterior, no evitamos un error ya que nada podría haber sucedido si
nuestro botón no muestra un texto en él; simplemente el usuario no vería nada.
Sin embargo, si se tratara de otro contexto podría haberse producido un fallo a
raíz de que no hicimos nuestros chequeos necesarios.

Posiblemente este no sea el ejemplo más preciso pero creo sirve a los fines de
que entiendan el funcionamiento de las _assertions_ en las listas de
inicialización y cómo adelantarnos escribiendo código defensivo.

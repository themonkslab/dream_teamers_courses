# _Errors, Exceptions and Assertions_

Hasta ahora venimos viendo errores, excepciones y aserciones, pero nunca
hablamos detenidamente de ellos y qu√© diferencias podemos encontrar entre un
tipo y el otro. Vamos a por ello!

__Los errores o _errors_ son fallos provocados por el desarrollador... cuando
hacemos algo mal!__ ü§£ Por ejemplo, podr√≠a ser llamar a una funci√≥n con argumentos
que no son v√°lidos, buscar un elemento en una lista que no tiene dicho √≠ndice o
cosas por el estilo! En estos casos, __nuestro programa deber√≠a terminar de forma
inmediata__ ya que no es seguro el continuar una vez que se han producido estos errores.

__Las excepciones o _exceptions_ por el otro lado, muestran que algo inesperado
sucedi√≥, algo fuera de nuestro control__. Sin embargo, pueden ser manejadas:
podr√≠amos mostrarle un mensaje al usuario y luego recuperarnos y continuar con
la ejecuci√≥n.

Finalmente, ya vimos lo que son __las _assertions_ o afirmaciones que nos permiten
chequear el c√≥digo cuando estamos en _debug mode_ o tiempo de desarrollo,__ pero
lo hicimos en los comienzos de este curso. Ahora que ya las manejamos, vamos a
relacionarlas con los errores y las excepciones!

Es importante tener en cuenta que las _assertions_ en la lista de inicializaci√≥n
se ejecutan en tiempo de compilaci√≥n y se omiten en tiempo de ejecuci√≥n en modo
release o cuando presentamos la app para el usuario. Por lo tanto, __no deben
utilizarse para validar entradas de usuario o comprobar condiciones que se
espera que se produzcan durante la ejecuci√≥n normal del programa__. __Las
_assertions_  se utilizan para detectar errores de programaci√≥n y asegurarse de
que las suposiciones del programador sobre el estado del programa sean correctas
en tiempo de ejecuci√≥n.__

## Manejando errores en la _initializer list_

En Flutter, _framework_ que trabaja utilizando Dart como lenguaje, contamos con
una estructura basada en _Widgets_ y se dice que cada elemento en Flutter es un
_Widget_. As√≠ por ejemplo, si queremos poner un bot√≥n en nuestra aplicaci√≥n,
este bot√≥n ser√° un _Widget_ y lo podr√≠amos representar de forma muy simple con
una clase:

```dart
class FlutterButton {
  FlutterButton({required this.text});
  final String text;
}
```

Este bot√≥n por el momento no podr√≠a hacer nada ya que solo recibe el texto que
va a mostrar. Pero qu√© impedir√≠a que le pasemos cuando lo construyamos a este
bot√≥n, un `String` vac√≠a?

```dart
void main() {
  final button = FlutterButton(text: '');
  print(button.text);
}
```

Absolutamente nada! Podr√≠amos crear un test entonces, para cerciorarnos de que
si le pasamos un `String` vac√≠a, nuestro constructor va a lanzar una excepci√≥n y
si le pasamos una `String` con caracteres, va a retornar normalmente:

```dart
void main() {
  group('Given a FlutterButton', () {
    test('When created with an empty text, Then should throw AssertionError', () {
      expect(() => FlutterButton(text: ''), throwsA(isA<AssertionError>()));
    });

    test('When created with text not empty, should return normally', () {
      expect(() => FlutterButton(text: 'Hello, world!'), returnsNormally);
    });
  });
}
```

Podemos observar varias cosas en nuestros tests:

### Funciones an√≥nimas o referencias a funci√≥n

- Utilizamos una funci√≥n an√≥nima como primer argumento en el `expect`:

Ustedes recuerdan que el m√©todo `expect` b√°sicamente compara dos argumentos.
Bien, para poder chequear un error lanzado por una _assertion_,
utilizamos `throwsA` o 'lanzar un' en espa√±ol. Este m√©todo recibe una funci√≥n
que luego ser√° ejecutada durante nuestro test. En el caso presente, dicha
funci√≥n es `isA<AssertionError>()` que corrobora el tipo de error que va a estar
siendo lanzado por nuestra _assertion_. De esta forma, `throwsA` encapsula a
`isA<AssertionError>()` para ser ejecutada en el `expect`.

Venimos bien hasta ah√≠? Perfecto. Seguimos!

En el segundo argumento tenemos esta funci√≥n que lanzar√° otra
funci√≥n. En nuestro primer argumento debi√©ramos tener algo similar y as√≠ poder
compararlo: necesitamos entonces una funci√≥n que lance otra funci√≥n.

Tenemos ya una funci√≥n que es la encargada de construir nuestro `FlutterButton`,
el constructor de dicha clase. Nos faltar√≠a entonces una funci√≥n que dispare
esta funci√≥n constructora. Para ello, __utilizamos una funci√≥n an√≥nima que sirve
para encapsular la creaci√≥n de la instancia de `FlutterButton`__ y as√≠ poder
comparar esta con aquella otra funci√≥n.

Si se les complic√≥, vuelvan a leerlo detenidamente porque es medio enrevesado! ü§£

- Utilizamos `returnsNormally`

Parecido al caso anterior, solo que este `returnsNormally` es un `matcher` que
machea una llamada a una funci√≥n cuando no produce ninguna excepci√≥n. Por eso,
el valor del primer argumento tiene nuevamente que ser una funci√≥n an√≥nima.

En ambos casos, __la funci√≥n an√≥nima es una referencia a una funci√≥n ya que se va
a ejecutar luego dentro del `expect` as√≠ como lo har√° el segundo t√©rmino del
mismo, pudiendo ambos finalmente compararse.__

Ya que entendimos como nuestros tests est√°n construidos, c√≥mo lo implementamos?
Vamos a utilizar las _assertions_ dentro del constructor, en la _initializer
list_.

En cuanto a la ubicaci√≥n de las _assertions_ en una inicializaci√≥n de lista, se
recomienda colocarlas al principio, inmediatamente despu√©s de los `:`, antes de
cualquier otra expresi√≥n. Esto es porque las _initializer list_ se eval√∫an de
izquierda a derecha, y si hay una expresi√≥n inv√°lida en la lista, la excepci√≥n
que se genera puede no estar relacionada con la expresi√≥n incorrecta. __Colocar
las _assertions_ al principio de la lista ayuda a identificar r√°pidamente
cualquier problema en los argumentos de entrada.__

```dart
class FlutterButton {
  FlutterButton({required this.text})
      : assert(text.isNotEmpty, 'Text can\'t be empty');
  final String text;
}
```

Ahora s√≠, si corremos los tests habiendo implementado la clase de esta manera,
vamos a estar seguros de que nuestro bot√≥n se va a construir de forma correcta.

Haciendo lo anterior, no evitamos un error ya que nada podr√≠a haber sucedido si
nuestro bot√≥n no muestra un texto en √©l; simplemente el usuario no ver√≠a nada.
Sin embargo, si se tratara de otro contexto podr√≠a haberse producido un fallo a
ra√≠z de que no hicimos nuestros chequeos necesarios.

Posiblemente este no sea el ejemplo m√°s preciso pero creo sirve a los fines de
que entiendan el funcionamiento de las _assertions_ en las listas de
inicializaci√≥n y c√≥mo adelantarnos escribiendo c√≥digo defensivo.

## Try and catch

Si nosotros en el ejemplo anterior corr√≠amos nuestra aplicaci√≥n creando uno de
nuestros botones pero lo hac√≠amos con un texto vac√≠o, √©sta se deten√≠a
completamente, no pudiendo completar la l√≠nea siguiente a la creaci√≥n de dicho
bot√≥n, porque lanzaba una excepci√≥n que no control√°bamos:

```dart
void main() {
  final button = FlutterButton(text: '');
  print('üòã Never gets here');
}
```

```shell
Unhandled exception:
'file:///Users/maurodibert/Development/dream_teamers/dream_teamers_courses/dart_sp/13.Async/general.dart': Failed assertion: line 4 pos 15: 'text.isNotEmpty': Text can't be empty
general.dart:4
#0      _AssertionError._doThrowNew (dart:core-patch/errors_patch.dart:51:61)
#1      _AssertionError._throwNew (dart:core-patch/errors_patch.dart:40:5)
#2      new FlutterButton
general.dart:4
#3      main
general.dart:23
#4      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#5      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)

Exited (255)
```

C√≥mo podemos controlarla? Utilizando _try_ (probar) y _catch_ (agarrar).
B√°sicamente este m√©todo nos permite intentar ejecutar c√≥digo y, si sucediera
alg√∫n fallo en dicha ejecuci√≥n, 'agarrarlo' o encapsularlo dentro de una
variable para que nosotros podamos hacer algo con √©l. Observemos:

```dart
void main() {
  try {
    final button = FlutterButton(text: '');
    // Si funciona
    // podr√≠amos utilizar ese bot√≥n aqu√≠
  } catch (e) {
    // (e es la variable que representa el error)
    // Si no funciona,
    // podemos imprimir el error
    print(e);
  }
  print('üöÄ Now, gets here!');
}
```

Lo que hicimos fue abrir un bloque para el intento dentro de `try {}` y luego
otro para el manejo del error en `catch (e)`, siendo como se ve en el ejemplo,
`e` la variable que almacena el error.

Esto es lo que van a poder observar si lo ejecutan:

```shell
'file:///Users/maurodibert/Development/dream_teamers/dream_teamers_courses/dart_sp/13.Async/general.dart': Failed assertion: line 4 pos 15: 'text.isNotEmpty': Text can't be empty
general.dart:4
üöÄ Now, gets here!

Exited
```

## Throw

Prueben el siguiente c√≥digo con los tests con los que ya contaban:

```dart
class FlutterButton {
  FlutterButton({
    required this.text,
  }) {
    if (text.isEmpty) {
      throw AssertionError('Text can\'t be empty');
    }
  }

  final String text;
}
```

Tuvieron alg√∫n error? Esto exactamente lo que hace una _assertion_: 'lanza' una
excepci√≥n que luego vamos a poder tratar, solo que lo hace de forma m√°s
suscinta.

__La _keyword_ `throw` lo que hace es simplemente lanzar algo y la
podemos utilizar en combinaci√≥n con excepciones en cualquier momento para
prevenir un posible error. Cuando digo prevenir me refiero a que nos permite
utilizar `try {} catch(e) {}` para encapsular el error y mostrarle algo adecuado
al usuario.__

## üí™ Completando el bot√≥n

Un bot√≥n no ser√≠a exactamente un bot√≥n si no hiciera algo al ser apretado verdad?

__Requirement__: Sumarle al bot√≥n creado un par√°metro llamado `onPressed` que
represente a una funci√≥n. Dicha funci√≥n puede ser nula ya que es una pr√°ctica
com√∫n el deshabilitar un bot√≥n al pas√°rsele una `onPressed` nula pero no puede
recibir una funci√≥n an√≥nima vac√≠a: `() {}`. Escriban los tests respectivos.

__Hint__: mmm... ya est√°n a la altura de no recibir ninguno! A investigar!

---

__üíÄ Soluci√≥n__:

```dart
import 'package:test/test.dart';

void main() {
  group('Given a FlutterButton', () {
    test('When created with an empty text, Then should throw AssertionError',
        () {
      expect(() => FlutterButton(text: ''), throwsA(isA<AssertionError>()));
    });

    test('When created with text not empty, should return normally', () {
      expect(() => FlutterButton(text: 'Hello, world!'), returnsNormally);
    });

    test(
        'When created with an empty onPressed, Then should throw AssertionError',
        () {
      expect(() => FlutterButton(text: 'Hello, world!', onPressed: () {}),
          throwsA(isA<AssertionError>()));
    });

    test(
        'When created with a onPressed that returns nothing, Then should throw AssertionError',
        () {
      expect(
          () => FlutterButton(
              text: 'Hello, world!',
              onPressed: () {
                // Do nothing
              }),
          throwsA(isA<AssertionError>()));
    });

    test(
        'When created with a onPressed that returns something, Then should return normally',
        () {
      expect(
          () => FlutterButton(
              text: 'Hello, world!', onPressed: () => print('test')),
          returnsNormally);
    });
  });
}

class FlutterButton {
  FlutterButton({
    required this.text,
    this.onPressed,
  }) {
    if (text.isEmpty) {
      throw AssertionError('Text can\'t be empty');
    }
    if (onPressed != null && onPressed.runtimeType == () {}.runtimeType) {
      throw AssertionError('onPressed can\'t be an empty function');
    }
  }

  final String text;
  final Function? onPressed;
}
```

__Explicaci√≥n__:

`onPressed.runtimeType` devuelve el tipo de tiempo de ejecuci√≥n de la funci√≥n
`onPressed`. Por ejemplo, si `onPressed` es una funci√≥n que retorna un `int`, su
tipo de tiempo de ejecuci√≥n ser√≠a `() => int`. En cambio, si `onPressed` es
una funci√≥n que no retorna nada (es decir, retorna `void`), su tipo de tiempo de
ejecuci√≥n ser√≠a `() => void`.

Por otro lado, `() {}.runtimeType` se refiere al tipo de tiempo de ejecuci√≥n de
una funci√≥n an√≥nima vac√≠a. En otras palabras, es una funci√≥n que no realiza
ninguna operaci√≥n y no devuelve ning√∫n valor, es decir, su tipo de tiempo de
ejecuci√≥n es `() => Null`.

He aqu√≠ la prueba:

```dart
void main() {
  final voidFunction = () => print('test');
  print(() {}.runtimeType);
  print(voidFunction.runtimeType);
}
```

```shell
() => Null
() => void
Exited
```

## Try catch reforzado

Ya tenemos un c√≥digo cada vez m√°s completo pero nuestro bot√≥n no ser√≠a un super
bot√≥n si no le pasamos un color de fondo. Vamos a simular ese color con un enum:

```dart
enum Color {lightBlue, darkBlue, red, green, yellow, orange, purple, pink, brown, grey, black, white }
```

Y vamos a agregarlo a nuestra clase con un valor por defecto:

```dart
class FlutterButton {
  FlutterButton({
    required this.text,
    this.color = Color.lightBlue,
    this.onPressed,
  }) {
    if (text.isEmpty) {
      throw AssertionError('Text can\'t be empty');
    }
    if (onPressed != null && onPressed.runtimeType == () {}.runtimeType) {
      throw AssertionError('onPressed can\'t be an empty function');
    }
  }

  final String text;
  final Function? onPressed;
  final Color color;
}
```

Cuando definimos nuestros colores, agregamos la mayor√≠a de los colores que
podr√≠amos utilizar a lo largo de nuestra aplicaci√≥n pero lo cierto es que alguno
de ellos son reservados: por ejemplo el color rojo ser√≠a mejor lo utiliz√°ramos
en situaciones de error.

Vamos entonces a agregar una excepci√≥n espec√≠fica cuando alguien le pase a este
bot√≥n el color rojo, una excepci√≥n que vamos a crear extendiendo la clase `Exceptions`:

```dart
class RedForErrorsException implements Exception {
  final String message;
  RedForErrorsException(this.message);
}

class FlutterButton {
  FlutterButton({
    required this.text,
    this.color = Color.lightBlue,
    this.onPressed,
  }) {
    if (text.isEmpty) {
      throw AssertionError('Text can\'t be empty');
    }
    if (onPressed != null && onPressed.runtimeType == () {}.runtimeType) {
      throw AssertionError('onPressed can\'t be an empty function');
    }
    if (color == Color.red) {
      throw RedForErrorsException('Color should be red just for errors');
    }
  }

  final String text;
  final Function? onPressed;
}
```

### On

Entonces, al momento de utilizar este bot√≥n podemos hacer algo espec√≠ficamente
cuando la excepci√≥n sea del tipo RedForErrorsException, utilizando la palabra
`on`:

```dart
void main() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException catch (e) {
    print('‚ò¢Ô∏è This is a RedForErrorsException');
    print(e.message);
  } catch (e) {
    print(e);
  }
  print('üöÄ Now, gets here!');
}
```

Si no necesit√°ramos de sus par√°metros, podr√≠amos omitir la palabra `catch`:

```dart
void main() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException { // üëÅÔ∏è
    print('‚ò¢Ô∏è This is a RedForErrorsException');
  } catch (e) {
    print(e);
  }
  print('üöÄ Now, gets here!');
}
```

### Stack trace

Ya lo vimos pero lo vamos a recordar: El _stack trace_ es una lista de llamadas a
funciones activas en un punto particular de la ejecuci√≥n del programa. Es decir,
cuando ocurre un error o una excepci√≥n en el c√≥digo, el _stack trace_ muestra la
secuencia de llamadas a funciones que llevaron a ese punto del c√≥digo. Se
utiliza com√∫nmente para depurar errores en el c√≥digo y para entender mejor c√≥mo
se comporta el programa en tiempo de ejecuci√≥n ya que muestra la ubicaci√≥n
exacta del error, lo que nos puede ayudar a identificar y corregir el problema.

Dentro de cada `catch`, el segundo par√°metro, nos permite obtenerlo y
utilizarlo:

```dart
void main() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException catch (e, stackTrace) {
    // üëÅÔ∏è
    print(stackTrace);
    print('‚ò¢Ô∏è This is a RedForErrorsException');
    print(e.message);
  } catch (e) {
    print(e);
  }
  print('üöÄ Now, gets here!');
}
```

```shell
#0      new FlutterButton
general.dart:14
#1      main
general.dart:85
#2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)

‚ò¢Ô∏è This is a RedForErrorsException
Color should be red just for errors
üöÄ Now, gets here!

Exited
```

### Finally

Podemos seguir sumando estad√≠os a nuestro `try {} catch(e,s) {}` y es el
`finally`, que nos permite hacer lo que queramos una vez que ya sucedi√≥ el `try`
y cada instancia de `catch` que queramos:

```dart
void main() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException catch (e, stackTrace) {
    print(stackTrace);
    print('‚ò¢Ô∏è This is a RedForErrorsException');
    print(e.message);
  } catch (e) {
    print(e);
  } finally {
    print('üé¨ Finally');
  }
  print('üöÄ Now, gets here!');
}
```

```shell
#0      new FlutterButton
general.dart:14
#1      main
general.dart:85
#2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)

‚ò¢Ô∏è This is a RedForErrorsException
Color should be red just for errors
üé¨ Finally
üöÄ Now, gets here!

Exited
```

### Rethrow

Supongamos que este c√≥digo que estamos escribiendo est√° metido mucho m√°s adentro
de nuestro `main`. Podr√≠amos hacer algo con la excepci√≥n `RedForErrorsException`
y luego volver a lanzarla para que otra capa de nuestro programa la maneje de
forma diferente; lo hacemos utilizando la _keyword_ `rethrow`:

```dart
void main() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException catch (e, stackTrace) {
    print(stackTrace);
    print('‚ò¢Ô∏è This is a RedForErrorsException');
    print(e.message);
    rethrow;
  } catch (e) {
    print(e);
  } finally {
    print('üé¨ Finally');
  }
  print('üöÄ Now, gets here!');
}
```

```shell
#0      new FlutterButton
general.dart:14
#1      main
general.dart:85
#2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)

‚ò¢Ô∏è This is a RedForErrorsException
Color should be red just for errors
üé¨ Finally

Unhandled exception:
Instance of 'RedForErrorsException'
#0      new FlutterButton
general.dart:14
#1      main
general.dart:85
#2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)

Exited (255)
```

All√≠ podemos ver como la excepci√≥n vuelve a ser lanzada una vez pasado todo el
proceso!

## üí™ Creando funci√≥n de creaci√≥n de bot√≥n

Nuevamente, recuerden que esto es solo a los fines de la pr√°ctica ya que en
Flutter van a ver que no es una buena pr√°ctica el crear _widgets_ desde
funciones.

__Requirement__: Encapsular todo el `try / catch` anterior en una funci√≥n y
crear otro `try / catch` que llame al anterior pero en este √∫ltimo, manejar la
excepci√≥n que relanzamos en el primero.

---

__üíÄ Soluci√≥n__:

```dart

void main() {
  try {
    createButton();
  } catch (e) {
    print('üßòüèª I manage excecptions by meditation');
    print(e);
  }
  print('üöÄ Now, gets here!');
}

void createButton() {
  try {
    final button = FlutterButton(text: 'Send', color: Color.red);
    // Hacer algo aqu√≠ con el super bot√≥n
  } on RedForErrorsException catch (e, stackTrace) {
    print(stackTrace);
    print('‚ò¢Ô∏è This is a RedForErrorsException');
    print(e.message);
    rethrow;
  } catch (e) {
    print(e);
  } finally {
    print('üé¨ Finally');
  }
}
```

## More exceptions

Quiero terminar este art√≠culo dici√©ndoles que si escriben `throw Exception` van
a poder seleccionar entre una larga lista de excepciones listas para utilizarse.
Sin embargo, al iniciar cualquier aplicaci√≥n, ser√≠a una buena pr√°ctica que
definan qu√© tipo de excepciones podr√≠an tener y ordenarlas en un archivo
destinado espec√≠ficamente a ello.

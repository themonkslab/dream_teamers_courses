# _Errors, Exceptions and Assertions_

Hasta ahora venimos vi茅ndolos pero nunca hablamos detenidamente de ellos y qu茅
diferencias podemos encontrar entre un tipo y el otro. Vamos a por ello!

__Los errores o _errors_ son fallos provocados por el desarrollador... cuando
hacemos algo mal!__ ぃ Por ejemplo, podr铆a ser llamar a una funci贸n con argumentos
que no son v谩lidos, buscar un elemento en una lista que no tiene dicho 铆ndice o
cosas por el estilo! En estos casos, __nuestro programa deber铆a terminar de forma
inmediata__ ya que no es seguro el continuar una vez que se han producido estos errores.

__Las excepciones o _exceptions_ por el otro lado, muestran que algo inesperado
sucedi贸, algo fuera de nuestro control__. Sin embargo, pueden ser manejadas:
podr铆amos mostrarle un mensaje al usuario y luego recuperarnos y continuar con
la ejecuci贸n.

Finalmente, ya vimos lo que son __las _assertions_ o afirmaciones que nos permiten
chequear el c贸digo cuando estamos en _debug mode_ o tiempo de desarrollo,__ pero
lo hicimos en los comienzos de este curso. Ahora que ya las manejamos, vamos a
relacionarlas con los errores y las excepciones!

Es importante tener en cuenta que las _assertions_ en la lista de inicializaci贸n
se ejecutan en tiempo de compilaci贸n y se omiten en tiempo de ejecuci贸n en modo
release o cuando presentamos la app para el usuario. Por lo tanto, __no deben
utilizarse para validar entradas de usuario o comprobar condiciones que se
espera que se produzcan durante la ejecuci贸n normal del programa__. __Las
assertions  se utilizan para detectar errores de programaci贸n y asegurarse de
que las suposiciones del programador sobre el estado del programa sean correctas
en tiempo de ejecuci贸n.__

## Manejando errores en la _initializer list_

En Flutter, _framework_ que trabaja utilizando Dart como lenguaje, contamos con
una estructura basada en _Widgets_ y se dice cada elemento en Flutter es un _Widget_.
As铆 por ejemplo, si queremos poner un bot贸n en nuestra aplicaci贸n, este bot贸n
ser谩 un _Widget_ y lo podr铆amos representar de forma muy simple con una clase:

```dart
class FlutterButton {
  FlutterButton({required this.text});
  final String text;
}
```

Este bot贸n por el momento no podr铆a hacer nada ya que solo recibe el texto que
va a mostrar. Pero qu茅 impedir铆a que le pasemos cuando lo construyamos a este
bot贸n, un `String` vac铆a?

```dart
void main() {
  final button = FlutterButton(text: '');
  print(button.text);
}
```

Absolutamente nada! Podr铆amos crear un test entonces, para cerciorarnos de que
si le pasamos un `String` vac铆a, nuestro constructor va a lanzar una excepci贸n y
si le pasamos una `String` con caracteres, va a retornar normalmente:

```dart
void main() {
  group('Given a FlutterButton', () {
    test('When created with an empty text, Then should throw AssertionError', () {
      expect(() => FlutterButton(text: ''), throwsA(isA<AssertionError>()));
    });

    test('When created with text not empty, should return normally', () {
      expect(() => FlutterButton(text: 'Hello, world!'), returnsNormally);
    });
  });
}
```

Podemos observar varias cosas en nuestros tests:

### Funciones an贸nimas o referencias a funci贸n

- Utilizamos una funci贸n an贸nima como primer argumento en el `expect`:

Ustedes recuerdan que el m茅todo `expect` b谩sicamente compara dos argumentos.
Bien, para poder chequear un error lanzado por una _assertion_,
utilizamos `throwsA` o 'lanzar un' en espa帽ol. Este m茅todo recibe una funci贸n
que luego ser谩 ejecutada durante nuestro test. En el caso presente, dicha
funci贸n es `isA<AssertionError>()` que corrobora el tipo de error que va a estar
siendo lanzado por nuestra _assertion_. De esta forma, `throwsA` encapsula a
`isA<AssertionError>()` para ser ejecutada en el `expect`.

Venimos bien hasta ah铆? Perfecto. Seguimos!

En el segundo argumento tenemos esta funci贸n que lanzar谩 otra
funci贸n. En nuestro primer argumento debi茅ramos tener algo similar y as铆 poder
compararlo: necesitamos entonces una funci贸n que lance otra funci贸n.

Tenemos ya una funci贸n que es la encargada de construir nuestro `FlutterButton`,
el constructor de dicha clase. Nos faltar铆a entonces una funci贸n que dispare
esta funci贸n constructora. Para ello, __utilizamos una funci贸n an贸nima que sirve
para encapsular la creaci贸n de la instancia de `FlutterButton`__ y as铆 poder
comparar esta con aquella otra funci贸n.

Si se les complic贸, vuelvan a leerlo detenidamente porque es medio enrevesado! ぃ

- Utilizamos `returnsNormally`

Parecido al caso anterior, solo que este `returnsNormally` es un `matcher` que
machea una llamada a una funci贸n cuando no produce ninguna excepci贸n. Por eso,
el valor del primer argumento tiene nuevamente que ser una funci贸n an贸nima.

En ambos casos, __la funci贸n an贸nima es una referencia a una funci贸n ya que se va
a ejecutar luego dentro del `expect` as铆 como lo har谩 el segundo t茅rmino del
mismo, pudiendo ambos finalmente compararse.__

Ya que entendimos c贸mo construimos nuestros tests, c贸mo lo implementamos? Vamos
a utilizar las _assertions_ dentro del constructor, en la _initializer list_.

En cuanto a la ubicaci贸n de las _assertions_ en una inicializaci贸n de lista, se
recomienda colocarlas al principio, inmediatamente despu茅s de los `:`, antes de
cualquier otra expresi贸n. Esto es porque las _initializer list_ se eval煤an de
izquierda a derecha, y si hay una expresi贸n inv谩lida en la lista, la excepci贸n
que se genera puede no estar relacionada con la expresi贸n incorrecta. __Colocar
las _assertions_ al principio de la lista ayuda a identificar r谩pidamente
cualquier problema en los argumentos de entrada.__

```dart
class FlutterButton {
  FlutterButton({required this.text})
      : assert(text.isNotEmpty, 'Text can\'t be empty');
  final String text;
}
```

Ahora s铆, si corremos los tests habiendo implementado la clase de esta manera,
vamos a estar seguros de que nuestro bot贸n se va a construir de forma correcta.

Haciendo lo anterior, no evitamos un error ya que nada podr铆a haber sucedido si
nuestro bot贸n no muestra un texto en 茅l; simplemente el usuario no ver铆a nada.
Sin embargo, si se tratara de otro contexto podr铆a haberse producido un fallo a
ra铆z de que no hicimos nuestros chequeos necesarios.

Posiblemente este no sea el ejemplo m谩s preciso pero creo sirve a los fines de
que entiendan el funcionamiento de las _assertions_ en las listas de
inicializaci贸n y c贸mo adelantarnos escribiendo c贸digo defensivo.

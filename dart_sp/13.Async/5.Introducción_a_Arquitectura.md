# Introducci√≥n a Arquitectura

Supongamos que queremos crear una app que se encarga de pedir un dato por
internet. Estuvimos hablando desde el principio de organizaci√≥n y orden verdad?
Es acaso que en un par de archivos tendremos toda nuestra aplicaci√≥n? Y ser√° que
tenemos que inventar el c√≥mo hacer toda esta aplicaci√≥n desde el principio?

Para todo lo anterior, existe la arquitectura de software.

La arquitectura de software __es la estructura y organizaci√≥n de los componentes
de un sistema de software, as√≠ como las relaciones y dependencias entre ellos__.
En t√©rminos simples, es la forma en que el software est√° dise√±ado y organizado
para cumplir con sus requisitos y objetivos.

La importancia de la arquitectura de software radica en que afecta directamente
la calidad y el √©xito del mismo. __Una buena arquitectura ayuda a crear un
sistema m√°s eficiente, escalable, f√°cil de mantener y extensible__. Adem√°s,
__permite la detecci√≥n y correcci√≥n temprana de problemas__, __reduce el tiempo
y el costo de desarrollo, y facilita la colaboraci√≥n y el trabajo en equipo__.

Como estamos por terminar nuestra parte inicial y aprendiendo a interactuar con
el mundo real digital, necesitamos empezar a ordenar la forma en la que
escribimos c√≥digo y saber que __existen convenciones que nos ayudan a avanzar
mucho m√°s r√°pido__ en el proceso; hablaremos de dos fundamentales.

## Separaci√≥n por capas

Algo fundamental es __organizar nuestro c√≥digo seg√∫n distintas capas para que
puedan utilizarse como piezas intercambiables__. Es com√∫n separar aquello con lo
que el usuario tiene que interactuar (presentaci√≥n o vista) con la l√≥gica para que
esa vista funcione (l√≥gica de negocio). Luego podemos tener a su vez otra capa
que se encargue de alcanzarle lo necesario a esa l√≥gica, transform√°ndola o
adapt√°ndola (repositorios) y finalmente, la capa que tiene la funci√≥n de obtener
los datos en bruto y pas√°rselos a la capa de repositorios (capa de datos).

```mermaid
flowchart TD;
  A[Presentaci√≥n]-->B[L√≥gica de negocios];
  B[L√≥gica de negocios]-->C[Repositorio];
  C[Repositorio]-->D[Datos];
```

__Lo interesante__ de la organizaci√≥n en capas es que __separa las diferentes
responsabilidades de la aplicaci√≥n en partes espec√≠ficas__ y cohesivas, lo que
hace que sea __m√°s f√°cil de entender__.

Veamos un ejemplo: tenemos una aplicaci√≥n que muestra un listado de capitales
del mundo y al hacer click en una de ellas, hace un pedido a un servidor. √âste
responde y dicha respuesta es adaptada a las clases que necesitamos y se acaba
mostrando una serie de datos sobre dicha ciudad.

```mermaid
graph 
  A[<b>Presentaci√≥n</b>: Muestra <i>dropdown</i> con listado de ciudades]
  -->|Usuario hace click\nen una ciudad|B[<b>L√≥gica de negocios</b>: Pone en estado de <i>loading</i> <br> y se conecta con repositorio]
  -->C[<b>Presentaci√≥n</b>: Muestra un indicador de progreso al usuario]
  -->D[<b>Repositorio</b>: Conecta con la <i>API</i> o capa de <b>Datos</b>\n elegida para traer los datos]
  -->E[<b>Datos</b>: Hace un pedido al servidor y lo devuelve]
  -->F[<b>Repositorio</b>: Adapta los datos recibidos a las clases que necesitamos]
  -->G[<b>L√≥gica de negocios</b>: Saca estado de <i>loading</i>,\nmuestra estado de <i>success</i>\ny provee datos a la capa de <b>Presentaci√≥n</b>]
  -->H[<b>Presentaci√≥n</b>: Deja de mostrar indicador de progreso <br> y muestra la informaci√≥n de la ciudad];

```

El que sea m√°s f√°cil de entender y el que est√© estratificado (separado por
capas), __permite que tambi√©n sea m√°s f√°cil de mantener ya que si alg√∫n error
sucede sabremos de qu√© capa proviene.__

Por otro lado, __permite una mayor escalabilidad__, lo que significa que la
aplicaci√≥n puede  __crecer y adaptarse a las necesidades del negocio sin afectar
las otras partes__ de la  aplicaci√≥n.

Por ejemplo, nuestra gente de _marketing_ podr√≠a querer ya no utilizar un
_dropdown_ sino un simple listado, cambio que ser√° muy f√°cil de realizar debido
a que solamente tenemos que alterar la capa de presentaci√≥n.

Lo mismo suceder√≠a si nuestros compa√±eros de _backend_ deciden utilizar otra
_API_ en el proceso de obtenci√≥n de datos ya que solamente esa capa ser√≠a la que
recibir√≠a modificaciones.

Finalmente, separar la aplicaci√≥n en capas __facilita la colaboraci√≥n entre
diferentes equipos de desarrollo__, ya que __cada equipo puede trabajar en su propia
capa__ de la aplicaci√≥n sin interferir en otras capas.

## Patrones de dise√±o

Los patrones de dise√±o son __soluciones comunes a problemas recurrentes que se
presentan en el desarrollo__. En general, los patrones de dise√±o se dividen en
tres categor√≠as: creacionales, estructurales y de comportamiento y hemos visto
ejemplos de cada una de ellas:

- __Patrones de creaci√≥n__: se utilizan para resolver problemas de creaci√≥n de
  objetos y para lograr una mayor flexibilidad en la creaci√≥n de objetos. Hemos
  utilizado y hablado sobre alguno de ellos:
  - _Singleton_: garantiza que solo haya una instancia de una clase en todo el
    programa.
  - _Factory_: cuando vimos constructores.
- __Patrones estructurales__: se enfocan en c√≥mo las clases y los objetos se
  combinan para formar estructuras m√°s grandes.
  - _Decorator_: se utiliza para agregar funcionalidad a un objeto existente sin
    modificar su estructura b√°sica.
- __Patrones de comportamiento__: se concentran en c√≥mo los objetos y las clases
  interact√∫an y distribuyen la responsabilidad entre ellas. Se utilizan para
  lograr una mayor flexibilidad y extensibilidad en la interacci√≥n entre objetos
  y clases.
  - _Extensions_: cuando quisimos agregar funcionalidad a una clase.

Cada categor√≠a de patrones de dise√±o tiene su propio enfoque y utiliza
diferentes t√©cnicas para resolver diferentes problemas de dise√±o. __La elecci√≥n
de un patr√≥n de dise√±o adecuado depender√° del problema espec√≠fico que se est√©
tratando de resolver y de los requisitos de dise√±o del sistema en general.__

## Por qu√©?

Ustedes se preguntar√°n por qu√© raz√≥n estamos viendo esto ahora? Porque est√°n a
punto de terminar de poseer las nociones b√°sicas para crear apps reales,
conectarse con servidores externos e interactuar con otras plataformas y
aplicaciones y si no empiezan pensando la _big picture_ o el panorama completo y
lo ordenan desde las bases, todo su proceso de creaci√≥n se har√° cada vez m√°s
complejo y limitado, les costar√° cada vez m√°s avanzar y por ende, van a
disfrutar bastante menos de este mundo que es genial!

## M√°s sobre futures

Hemos estado utilizando el constructor `Future.delayed` para regresar un valor
luego de haber transcurrido un tiempo. M√°s espec√≠ficamente ejecut√°bamos un
_callback_ luego de haber transcurrido una determinada cantidad de tiempo.

Ahora que hemos tenido una suerte de introducci√≥n a arquitectura en software,
vamos a tratar de ordenarnos un poquito y ver en un ejemplo c√≥mo podemos
separar nuestra app por capas y hacer el proceso de desarrollo m√°s eficaz; vamos
a hacerlo utilizando otro de los constructores de los _futures_.

En el proceso de desarrollo de una app, algo que puede resultarnos muy √∫til es
trabajar en una capa a la vez. As√≠, si recordamos la √∫ltima idea de aplicaci√≥n
con la que estuvimos experimentando, se encargaba de contactar a un restaurant
para solicitar una mesa.

Imaginemos que estamos con dicha app. Podr√≠amos estructurarla de forma muy
similar a la que vimos en aquella aplicaci√≥n que ped√≠a datos de ciudades:

- __Presentaci√≥n__: muestra un campo donde nos pide ingresar el n√∫mero de comensales
  y un bot√≥n de enviar para realizar la reserva. Dicho bot√≥n muestra un
  indicador de progreso cuando est√° realizando el pedido al restaurant.
- __L√≥gica de negocio__: maneja los estados (_loading_, _error_ y _success_) de
  nuestra vista o __presentaci√≥n__ y se conecta con un repositorio.
- __Repositorio__: se conecta con nuestra capa de datos y luego va a transformar
  su respuesta en algo susceptible de ser manejado por nuestra app.
- __Datos__: se conecta con la _API_ del restaurant.

Si nos encarg√°ramos de realizar esta app, podr√≠amos empezar por solo una de
estas vistas. En general, si ya tuvi√©ramos todas las herramientas, a m√≠
personalmente me gusta arrancar desde la capa del __repositorio__ en donde
defino los modelos o clases con los que nuestra aplicaci√≥n va a trabajar, porque
me permite entenderla m√°s en detalle; ahora sin embargo, vamos a trabajar
superficialmente como si trabaj√°ramos con la capa de __presentaci√≥n__ como
excusa para aprender algo m√°s sobre futuros y sobre capas.

### Trabajando en la presentaci√≥n

Sup√≥nganse que nos basamos en el ejemplo de pedido de mesa como si fuera una
aplicaci√≥n por l√≠nea de comando. En primer lugar, recibir√≠amos al usuario, luego
le preguntar√≠amos de cu√°ntos comensales necesitar√≠a la reserva para enviar dicho
_request_ al restaurant y finalmente ofrecerle la confirmaci√≥n o un error en el
caso de que algo inesperado haya sucedido:

```dart
void main() async {
  stdout.write('Welcome to our restaurant! üçΩÔ∏è\nHow many people are you? ');
  int diners = int.parse(stdin.readLineSync()!);
  bool table = await doWeHaveTable(diners); // Cambiamos el nombre de la funci√≥n para que sea m√°s descriptiva
  printResult(table);
}
```

De momento, si trabaj√°ramos por capas, podr√≠amos sumar lo siguiente a nuestro
c√≥digo:

```dart
void printResult(bool value) {
  if (value == true) {
    print('You have a table! ü•≥');
  } else {
    print('You don\'t have a table! üòã');
  }
  print('We hope to see you soon! ü§ó');
}
```

La funci√≥n `doWeHaveTable` es la que se tiene que encargar de interactuar con
otra de las capas de nuestra aplicaci√≥n, la capa de la l√≥gica de negocio que a
su vez tiene que comunicarse con nuestro repositorio. Sin embargo, de momento no
nos interesa desarrollar m√°s que solamente la vista y adem√°s, nos falta aprender
apenas algo m√°s para lograr crear todas las capas. Por ello y para crear
solamente la vista, vamos a reemplazar todas las otras capas utilizando un
constructor nuevo de nuestra clase `Future`, `Future.value`.

`Future.value` nos permite retornar un valor de forma instant√°nea, sin tener que
esperar por este valor. Es una forma de no preocuparnos por el pedido al
servidor en este preciso momento, para poder testar la vista en caso de √©xito o
error; m√°s adelante continuar√≠amos con dichas capas.

Entonces, creamos la funci√≥n `doWeHaveTable(diners)` que va a retornar de
momento, el caso de √©xito:

```dart
Future<bool> doWeHaveTable(int diners) {
  return Future.value(true);
}
```

Con esto, si corremos nuestra aplicaci√≥n, veremos si lo que hicimos para
responder en caso de error, funciona de forma correcta:

```shell
Welcome to our restaurant! üçΩÔ∏è
How many people are you? 3
You have a table! ü•≥
We hope to see you soon! ü§ó
```

De la misma forma, podr√≠amos transformar nuestra funci√≥n `doWeHaveTable` para
que retorne un caso en donde no tienen mesa disponible:

```dart
Future<bool> doWeHaveTable(int diners) {
  return Future.value(false);
}
```

```shell
Welcome to our restaurant! üçΩÔ∏è
How many people are you? 3
You don't have a table! üòã
We hope to see you soon! ü§ó
```

Y finalmente podr√≠amos retornar nuestro caso de error:

```dart
Future<bool> doWeHaveTable(int diners) {
  throw Exception('Something went wrong! üò±');
}
```

Que si corremos, nos damos cuenta...

```shell
Welcome to our restaurant! üçΩÔ∏è
How many people are you? 3
Unhandled exception:
Exception: Something went wrong! üò±
#0      doWeHaveTable (file:///Users/maurodibert/Development/dream_teamers/dream_teamers_courses/dart_sp/13.Async/general.dart:40:3)
#1      main (file:///Users/maurodibert/Development/dream_teamers/dream_teamers_courses/dart_sp/13.Async/general.dart:6:22)
#2      _delayEntrypointInvocation.<anonymous closure> (dart:isolate-patch/isolate_patch.dart:297:19)
#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:192:12)
```

...que nuestro c√≥digo en la vista, no lo maneja de forma correcta! üò≠ Vieron?
Para esto sirve separar el c√≥digo por capas: si habr√≠amos estado trabajando en
varias capas al mismo tiempo, podr√≠amos habernos salteado esto √∫ltimo con la
intenci√≥n de movernos m√°s r√°pido porque no lo habr√≠amos previsto. As√≠, podemos
solo concentrarnos en un √°rea a la vez y hacerlo de forma completa!

```dart
void main() async {
  stdout.write('Welcome to our restaurant! üçΩÔ∏è\nHow many people are you? ');
  int diners = int.parse(stdin.readLineSync()!);

  try {
    bool table = await doWeHaveTable(diners);
    printResult(table);
  } catch (e) {
    print('Error: ${e}');
  }
}
```

```shell
Welcome to our restaurant! üçΩÔ∏è
How many people are you? 3
Error: Exception: Something went wrong! üò±
```

De la misma forma, podr√≠amos utilizar otro constructor de `Future` en el caso de
que la operaci√≥n retorne un error: `Future.error`.

```dart
Future<bool> doWeHaveTable(int diners) {
  return Future.error(Exception('Something went wrong! üò±'));
}
```

```shell
Welcome to our restaurant! üçΩÔ∏è
How many people are you? 3
Error: Exception: Something went wrong! üò±
```

El _take away_ o lo que espero se lleven de este art√≠culo es de la importancia
de estructurar nuestra app y c√≥mo el hacerlo en nuestro proceso de creaci√≥n nos
puede ayudar enormemente ya que nos permite abarcar de forma profunda la
funcionalidad y cerrar por etapas, pudiendo mostrar a nuestros compa√±eros el
trabajo realizado o bien permitiendo que ellos trabajen al mismo tiempo, en
otras √°reas.

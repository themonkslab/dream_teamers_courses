# Futures, aproximaci贸n

Esto se va poniendo cada vez m谩s lindo porque desde este art铆culo, vamos a ver
lo 煤ltimo necesario para poder empezar a crear aplicaciones que interact煤en con
el mundo exterior a nuestra computadora.

Como ya conocen por experiencia propia, el interactuar con otros, requiere de
tiempo: alguien habla, el otro espera y escucha. Con nuestras aplicaciones
sucede lo mismo: pedimos un dato a un servidor en alg煤n lugar de internet y
mientras esperamos. Sin embargo, imag铆nense si mientras un dato est谩 viniendo
hacia nuestra aplicaci贸n, no pudi茅ramos hacer nada!

Van a existir caso para los cuales tendremos que esperar s铆 o s铆 y si el
resultado de esta operaci贸n no sucede en el tiempo que estimamos deber铆a haber
sucedido, podremos mostrar un mensaje al usuario y volver a intentarlo. Van a
existir otros casos en los que podremos enviar un pedido y mientras este recorre
ceros y unos por alg煤n lugar del universo, haremos otras cosas.

__Todos estos procesos de espera y el mientras tanto, reciben el nombre de asincron铆a.__

Las operaciones as铆ncronas son aquellas que no bloquean la ejecuci贸n
del programa y permiten que otros procesos se ejecuten mientras esperan la
finalizaci贸n de la operaci贸n en cuesti贸n. Estas operaciones se utilizan para
realizar tareas que pueden llevar un tiempo prolongado, como la descarga de
datos de Internet o la ejecuci贸n de operaciones de E/S (Entrada/Salida) en
archivos.

Para comenzar con estas operaciones as铆ncronas, Dart nos proporciona el concepto
de Futuros.

## Futures

Un _Future_ es __un objeto que representa el resultado potencial de una
operaci贸n as铆ncrona.__ Cuando se crea un _Future_, se inicia una tarea en segundo
plano que realizar谩 la operaci贸n as铆ncrona y devolver谩 un valor al _Future_ cuando
la tarea haya finalizado. Mientras tanto, la ejecuci贸n del programa puede
continuar sin bloquearse. Para trabajar con Futuros se utilizan una serie de m茅todos y
operaciones que vamos a ver de a poco!

Supongamos que vamos a simular una aplicaci贸n de un restaurant que nos dice,
dado un n煤mero de comensales, si tiene disponibilidad o no en el momento. Para
ello, vamos a empezar como bien ya ustedes saben, creando un test:

```dart
void main() {
  test(
      'Given a askForTable function, When executed with a N number of diners, Then it should return if has or not cappacity',
      () {
    // Given
    final diners = 5;

    // When
    final result = askForTable(diners);

    // Then
    expect(result, true);
  });
}
```

Tenemos nuestro test realizado seg煤n lo que vimos hasta ahora aunque imaginemos
un poco la situaci贸n:

1. Env铆o un pedido a esta aplicaci贸n.
2. Le llega al sistema y este debe chequear la cantidad de mesas ocupadas adem谩s
   de la lista de espera que puede tener en el mismo restaurant.

El segundo punto puede tomar alg煤n tiempo por lo que no es una respuesta que
podamos tener en el momento. Por ello, nuestros tests van a tener que cambiar:

```dart
void main() {
  group('Given a group of diners', () {
    test('When there are more than 4 diners, Then askForTable returns false',
        () {
      expectLater(askForTable(5), completion(isFalse));
    });

    test(
        'When there are less than or equal to 4 diners, Then askForTable returns true',
        () {
      expectLater(askForTable(4), completion(isTrue));
    });
  });
}
```

En primer lugar, van a ver que las descripciones cambiaron un poco y lo
ordenamos en un grupo. Adem谩s de esto, tenemos m茅todos que no conoc铆an:

### `expectLater`

El m茅todo `expectLater` en un test es similar al `expect`, pero adem谩s de
verificar el valor de la expresi贸n que se est谩 evaluando, tambi茅n permite
trabajar con un flujo en donde tenemos demoras en el tiempo.

En el ejemplo, el `expectLater` se utiliza para verificar que el
valor que retorna la funci贸n `askForTable` sea igual a `true`
cuando se le pasa un n煤mero de comensales menor o igual a 4, y `false` en caso
contrario.

### `completion`

El `completion` es un argumento opcional que se puede pasar a la funci贸n
`expectLater` y sirve para especificar una funci贸n de _callback_ que se llamar谩
cuando el futuro asociado (nuestra funci贸n `askForTable`) se complete.

### callback

Un _callback_ es una funci贸n que se pasa como argumento a otra funci贸n y que ser谩
llamada dentro de esa funci贸n en un momento espec铆fico o cuando se cumpla alguna
condici贸n determinada. El prop贸sito es especificar el comportamiento que se debe
ejecutar en una determinada situaci贸n.

Los _callbacks_ son muy comunes en programaci贸n asincr贸nica, donde se utilizan
para notificar al cliente que un proceso se ha completado o que se ha producido
un error. Por ejemplo, en nuestra caso, `isTrue` es el _callback_ que recibe
nuestro _matcher_ llamado `completion` y lo que va a hacer es comparar el
resultado de `askFormTable`.

Para todo lo anterior, necesitamos que nuestra funci贸n simule una demora y esto
va a agregar varias cosas que no conocemos:

```dart
// Ya no esperamos simplemente un bool, sino que esperamos un Future<bool>;
// es la forma de representar que la funci贸n va a devolver un valor en el futuro.
Future<bool> askForTable(int diners) {
  // Para hacerlo utilizamos Future.delayed que es una funci贸n que nos permite
  // crear un Future que se va a resolver en el tiempo que estipulemos.
  // En este caso, el Future se va a resolver en 3 segundos.
  // El segundo par谩metro es una funci贸n que se va a ejecutar cuando el Future
  // se resuelva. Y es un callback que devuelve un bool.
  return Future.delayed(Duration(seconds: 3), () {
    if (diners > 4) {
      return false;
    } else {
      return true;
    }
  });
}
```

Si ejecutan el test van a poder observar que se toma su tiempo; de hecho pueden
subir la cantidad a 10 segundos para que as铆 no les quede ninguna duda de que
existe una demora real.

Tenemos test, tenemos funci贸n... c贸mo la utilizamos? As铆?

```dart
void main() {
  print(' The process has started!');
  final result = askForTable(5);
  print(result);
}
```

### `then`

Como dijimos anteriormente, tendr铆amos que esperar que `askForTable` haga lo que
tenga que hacer y para ello los _futures_ cuentan con el m茅todo `then`:

```dart
void main() {
  print(' The process has started!');
  // Para utilizar el Future, lo que hacemos es llamar a la funci贸n y
  // utilizar el m茅todo then. El m茅todo then recibe una funci贸n que se va a
  // ejecutar cuando el Future se resuelva.
  askForTable(5).then((value) => print(value));
}
```

Podr铆amos hacer algo un poco m谩s _user friendly_ verdad?

```dart
void main() {
  print(' The process has started!');
  // Para utilizar el Future, lo que hacemos es llamar a la funci贸n y
  // utilizar el m茅todo then. El m茅todo then recibe una funci贸n que se va a
  // ejecutar cuando el Future se resuelva.
  askForTable(5).then((value) {
    if (value == true) {
      print('You have a table! コ');
    } else {
      print('You don\'t have a table! ');
    }
  });
}
```

Si corremos nuestra aplicaci贸n veremos que demora 3 segundos y luego nos
arroja el resultado:

```shell
 The process has started!
You don't have a table! 
Exited
```

Sin embargo, supongamos que podr铆a pasar algo en el sistema
del restaurant y en lugar de respondernos exitosamente, nos env铆an un fallo.
Vamos a arrojar una `Exception` y de momento comentar el otro c贸digo:

```dart
Future<bool> askForTable(int diners) {
  return Future.delayed(Duration(seconds: 3), () {
    return throw Exception('We had a problem with the server');
    // if (diners > 4) {
    //   return false;
    // } else {
    //   return true;
    // }
  });
}
```

Si nosotros corri茅ramos la app ahora, ver铆amos una excepci贸n a los tres segundos
de haberlo corrido verdad? C贸mo podr铆amos manejar esa excepci贸n?

### `catchError`

Para no interrumpir la ejecuci贸n de nuestro programa, utilizamos `catchError`
que es una funci贸n que recibe otro _callback_ a ser ejecutado si sucediera un error:

```dart
void main() {
  print(' The process has started!');
  askForTable(5).then((value) {
    if (value == true) {
      print('You have a table! コ');
    } else {
      print('You don\'t have a table! ');
    }
    // El m茅todo catchError se ejecuta cuando se produce un error
  }).catchError((error) {
    print('Error: $error');
  });
}
```

Y si ahora corren la app, ver谩n que nuestro error fue manejado gustozamente!

```shell
 The process has started!
Error: Exception: We had a problem with the server
Exited
```

Y podr铆amos completar el proceso imprimiendo algo que indique que se ha
finalizado. Podr铆amos hacer algo simple:

```dart
void main() {
  print(' The process has started!');
  askForTable(5).then((value) {
    if (value == true) {
      print('You have a table! コ');
    } else {
      print('You don\'t have a table! ');
    }
    // El m茅todo catchError se ejecuta cuando se produce un error
  }).catchError((error) {
    print('Error: $error');
  });
  print('The process has finished! ');
}
```

Sin embargo cuando corren la aplicaci贸n van a ver que pareciera que el proceso
termin贸 antes de comenzar!  Esto es debido a que el _future_ toma tres
segundos pero mientras la aplicaci贸n sigue:

```shell
 The process has started!
The process has finished! 
Error: Exception: We had a problem with the server
Exited
```

Para poder lograr lo que queremos, vamos a utilizar otro m茅todo m谩s de los
_futures_.

### `whenComplete`

Nuevamente, otro m茅todo que recibe un _callback_ encargado de ejecutarse luego
de los m茅todos anteriores:

```dart
void main() {
  print(' The process has started!');
  askForTable(5).then((value) {
    if (value == true) {
      print('You have a table! コ');
    } else {
      print('You don\'t have a table! ');
    }
    // El m茅todo catchError se ejecuta cuando se produce un error
  }).catchError((error) {
    print('Error: $error');
  }).whenComplete(() => print('The process has finished! '));
}

```

Eliminemos la excepci贸n:

```dart
Future<bool> askForTable(int diners) {
  return Future.delayed(Duration(seconds: 3), () {
    if (diners > 4) {
      return false;
    } else {
      return true;
    }
  });
}
```

Y ahora s铆, vamos a tener todo en orden:

```shell
 The process has started!
You don't have a table! 
The process has finished! 
Exited
```

Bien! Estamos empezando a manejar el tiempo en nuestras app aunque lo que vimos
en este cap铆tulo es solo a modo de introducci贸n, para que tomen consciencia de
c贸mo el tiempo transcurre en la ejecuci贸n ya que no es la forma 贸ptima de tratar
con operaciones as铆ncronas. Para ello, vayan al pr贸ximo cap铆tulo!
